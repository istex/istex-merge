const { create } = require('xmlbuilder2');
const _ = require('lodash');

/**
 * Generates a Hal TEI from a unified record.
 * @param {object} unifiedRecord The unified record generated by `select`.
 * @param {string} path The path to write the TEI file to.
 * @returns {string} The XML string.
 */
function generateHalTEI (unifiedRecord) {
  const xmlDoc = {};
  xmlDoc.TEI = {};

  // Set the root TEI node attributes
  xmlDoc.TEI['@xmlns'] = 'http://www.tei-c.org/ns/1.0';
  xmlDoc.TEI['@xmlns:hal'] = 'http://hal.archives-ouvertes.fr/';

  // Create the base <text> structure
  _.set(xmlDoc.TEI, 'text.body.listBibl.biblFull', {});
  const biblFull = xmlDoc.TEI.text.body.listBibl.biblFull;

  // Titles
  if (_.isObject(unifiedRecord.title)) {
    insertTitles(biblFull, unifiedRecord);
  }

  // Authors
  if (_.isArray(unifiedRecord.authors) && !_.isEmpty(unifiedRecord.authors)) {
    insertAuthors(biblFull, unifiedRecord);
  }

  // Identifiers
  insertIdentifiers(biblFull, unifiedRecord);

  // Language
  if (_.isArray(unifiedRecord.language) && !_.isEmpty(unifiedRecord.language)) {
    insertLanguage(biblFull, unifiedRecord);
  }

  // Abstract
  if (_.isObject(unifiedRecord.abstract)) {
    insertAbstract(biblFull, unifiedRecord);
  }

  // Catalog data
  insertCatalogData(biblFull, unifiedRecord);

  return create(xmlDoc).end();
}

/**
 * Inserts the titles from `unifiedRecord` into `biblFull`.
 * @param {object} biblFull The <biblFull> node to insert the titles in.
 * @param {object} unifiedRecord The unified record to get the titles from.
 */
function insertTitles (biblFull, unifiedRecord) {
  // Initialize the title container
  if (!_.has(biblFull, 'titleStmt.title')) {
    _.set(biblFull, 'titleStmt.title', []);
  }
  if (!_.has(biblFull, 'sourceDesc.biblStruct.monogr.title')) {
    _.set(biblFull, 'sourceDesc.biblStruct.monogr.title', []);
  }

  const titles = biblFull.titleStmt.title;
  const monogrTitles = biblFull.sourceDesc.biblStruct.monogr.title;

  // English title
  if (_.get(unifiedRecord, 'title.en')) {
    titles.push({ '@xml:lang': 'en', '#': unifiedRecord.title.en });
  }

  // French title
  if (_.get(unifiedRecord, 'title.fr')) {
    titles.push({ '@xml:lang': 'fr', '#': unifiedRecord.title.fr });
  }

  // Journal title
  if (_.get(unifiedRecord, 'title.journal')) {
    monogrTitles.push({ '@level': 'j', '#': unifiedRecord.title.journal });
  }

  // Monography title
  if (_.get(unifiedRecord, 'title.monography')) {
    monogrTitles.push({ '@level': 'm', '#': unifiedRecord.title.monography });
  }

  // Meeting title
  if (_.get(unifiedRecord, 'title.meeting')) {
    monogrTitles.push({ '@level': 'm', '#': unifiedRecord.title.meeting });
  }

  // The title is repeated under <sourceDesc>
  _.set(biblFull, 'sourceDesc.biblStruct.analytic.title', titles);
}

/**
 * Inserts the authors from `unifiedRecord` into `biblFull`.
 * @param {object} biblFull The <biblFull> node to insert the authors in.
 * @param {object} unifiedRecord The unified record to get the authors from.
 */
function insertAuthors (biblFull, unifiedRecord) {
  // Initialize the author container
  if (!_.has(biblFull, 'titleStmt.author')) {
    _.set(biblFull, 'titleStmt.author', []);
  }

  const authors = unifiedRecord.authors;

  authors.forEach(author => {
    const halAuthor = {};

    // Role
    halAuthor['@role'] = 'aut';

    // Name
    halAuthor.persName = {
      forename: { '@type': 'first', '#': author.forename },
      surname: author.surname,
    };

    // idRef
    if (!_.isEmpty(author.idRef)) {
      if (!_.has(halAuthor, 'idno')) halAuthor.idno = [];

      halAuthor.idno.push({ '@type': 'http://www.idref.fr/', '#': author.idRef[0] });
    }

    biblFull.titleStmt.author.push(halAuthor);
  });

  // The authors are repeated under <sourceDesc>
  _.set(biblFull, 'sourceDesc.biblStruct.analytic.author', biblFull.titleStmt.author);
}

/**
 * Inserts the identifiers from `unifiedRecord` into `biblFull`.
 * @param {object} biblFull The <biblFull> node to insert the identifiers in.
 * @param {object} unifiedRecord The unified record to get the identifiers from.
 */
function insertIdentifiers (biblFull, unifiedRecord) {
  // Initialize the identifier containers
  if (!_.has(biblFull, 'sourceDesc.biblStruct.monogr.idno')) {
    _.set(biblFull, 'sourceDesc.biblStruct.monogr.idno', []);
  }

  if (!_.has(biblFull, 'sourceDesc.biblStruct.idno')) {
    _.set(biblFull, 'sourceDesc.biblStruct.idno', []);
  }

  // DOI
  if (unifiedRecord.doi) {
    biblFull.sourceDesc.biblStruct.idno.push({ '@type': 'doi', '#': unifiedRecord.doi });
  }

  // PMID
  if (unifiedRecord.pmId) {
    biblFull.sourceDesc.biblStruct.idno.push({ '@type': 'pubmed', '#': unifiedRecord.pmId });
  }

  // ISSN
  if (!_.isEmpty(unifiedRecord.issn)) {
    biblFull.sourceDesc.biblStruct.monogr.idno.push({ '@type': 'issn', '#': unifiedRecord.issn });
  }

  // EISSN
  if (!_.isEmpty(unifiedRecord.eissn)) {
    biblFull.sourceDesc.biblStruct.monogr.idno.push({ '@type': 'eissn', '#': unifiedRecord.eissn });
  }
}

/**
 * Inserts the language from `unifiedRecord` into `biblFull`.
 * @param {object} biblFull The <biblFull> node to insert the language in.
 * @param {object} unifiedRecord The unified record to get the language from.
 */
function insertLanguage (biblFull, unifiedRecord) {
  // Initialize the language container
  if (!_.has(biblFull, 'profileDesc.langUsage.language')) {
    _.set(biblFull, 'profileDesc.langUsage.language', []);
  }

  for (const languageName of unifiedRecord.language) {
    const currentLanguageNode = {};

    // Records should only be in either English or French
    const languageNameLower = languageName.toLowerCase();
    if (languageNameLower.includes('english')) {
      currentLanguageNode['@ident'] = 'en';
    } else if (languageNameLower.includes('french')) {
      currentLanguageNode['@ident'] = 'fr';
    } else {
      currentLanguageNode['@ident'] = 'und';
    }

    // The text content of a node is under the '#' key with xmlbuilder2
    currentLanguageNode['#'] = languageName;

    biblFull.profileDesc.langUsage.language.push(currentLanguageNode);
  }
}

/**
 * Inserts the abstract from `unifiedRecord` into `biblFull`.
 * @param {object} biblFull The <biblFull> node to insert the abstract in.
 * @param {object} unifiedRecord The unified record to get the abstract from.
 */
function insertAbstract (biblFull, unifiedRecord) {
  let language;
  if (unifiedRecord.abstract.en) language = 'en';
  else if (unifiedRecord.abstract.fr) language = 'fr';

  // Create the abstract node
  if (!_.has(biblFull, 'profileDesc.abstract')) {
    _.set(biblFull, 'profileDesc.abstract', {});
  }

  biblFull.profileDesc.abstract = { '@xml:lang': language, p: unifiedRecord.abstract[language] };
}

/**
 * Inserts the catalog data from `unifiedRecord` into `biblFull`.
 * @param {object} biblFull The <biblFull> node to insert the catalog data in.
 * @param {object} unifiedRecord The unified record to get the catalog data from.
 */
function insertCatalogData (biblFull, unifiedRecord) {
  // Initialize the catalog data container
  if (!_.has(biblFull, 'sourceDesc.biblStruct.monogr.imprint.biblScope')) {
    _.set(biblFull, 'sourceDesc.biblStruct.monogr.imprint.biblScope', []);
  }
  if (!_.has(biblFull, 'sourceDesc.biblStruct.monogr.imprint.date')) {
    _.set(biblFull, 'sourceDesc.biblStruct.monogr.imprint.date', []);
  }

  const biblScopes = biblFull.sourceDesc.biblStruct.monogr.imprint.biblScope;
  const dates = biblFull.sourceDesc.biblStruct.monogr.imprint.date;

  // Issue
  if (unifiedRecord.issue) {
    biblScopes.push({ '@unit': 'issue', '#': unifiedRecord.issue });
  }

  // Page range
  if (unifiedRecord.pageRange) {
    biblScopes.push({ '@unit': 'pp', '#': unifiedRecord.pageRange });
  }

  // Volume
  if (unifiedRecord.volume) {
    biblScopes.push({ '@unit': 'volume', '#': unifiedRecord.volume });
  }

  // Publication date
  if (unifiedRecord.publicationDate) {
    dates.push({ '@type': 'datePub', '#': unifiedRecord.publicationDate });
  }

  // Electronic publication date
  if (unifiedRecord.electronicPublicationDate) {
    dates.push({ '@type': 'dateEpub', '#': unifiedRecord.electronicPublicationDate });
  }

  // Publisher
  if (unifiedRecord.publisher) {
    _.set(biblFull, 'sourceDesc.biblStruct.monogr.imprint.publisher', unifiedRecord.publisher);
  }
}

module.exports = generateHalTEI;
